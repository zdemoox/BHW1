# BHW1
Consol App for Banking

1. Инструкция по запуску: есть .sln файл, который собирает проект. В бинарнике выходной файл json и csv.

2. Общая идея решения:

Проект реализует систему учета банковских операций с поддержкой (в Program.cs написана примерная обработка данных):

а) Управления данными:

    Создание счетов (BankAccount), категорий (Category), операций (Operation).

    Обновление баланса счетов при добавлении операций (доходы/расходы).

б) Аналитики:

    Расчет разницы между доходами и расходами за период.

    Группировка операций по категориям.

в) Импорта/Экспорта:

    Поддержка JSON и CSV (реализовано через паттерны Visitor и Template Method).

    Сохранение идентификаторов объектов и связей между ними.

г) Паттернов проектирования:

    Команды (ICommand) с декораторами для логирования времени выполнения.
    
    Фабрики для создания операций с валидацией.

    Шаблонные методы для импорта данных.
    
3. Принципы из SOLID и GRASP:

Solid:

а) Single Responsibility (SRP):

    Каждый класс имеет одну ответственность:

    BankAccountService управляет счетами.

    AnalyticsService обрабатывает аналитику.

    JsonExportVisitor реализует экспорт в JSON.

    Пример: Класс CsvImporter отвечает только за парсинг CSV.

б) Open/Closed (OCP):

Расширение функционала без изменения кода:

    Добавление новых форматов импорта (наследование от DataImporter).

    Декоратор TimingCommandDecorator добавляет замер времени к командам.

    Пример: JsonImporter и CsvImporter расширяют DataImporter.

в) Liskov Substitution (LSP):

    Наследники DataImporter (например, JsonImporter) полностью заменяют базовый класс.

    Пример: Метод ImportData() работает с любым наследником DataImporter.

г) Interface Segregation (ISP):

    Интерфейсы узконаправленные:

    ICommand содержит только метод Execute().

    IExportVisitor определяет методы для сериализации объектов.

    Пример: IExportVisitor не заставляет реализовывать ненужные методы.
    
д) Dependency Inversion (DIP):

    Зависимости внедряются через конструкторы:

    JsonImporter принимает сервисы, а не создает их.

    AddOperationCommand зависит от IOperationService, а не конкретной реализации.

Grasp:

а) Creator:

    Сервисы (BankAccountService, CategoryService) создают объекты, которыми управляют.

    Пример: BankAccountService.CreateAccount().

б) Information Expert:

Классы, владеющие данными, обрабатывают их:

    OperationService вычисляет баланс.

    AnalyticsService группирует операции по категориям.

в) Low Coupling:

    Модули слабо связаны через интерфейсы (ICommand, IExportVisitor).

    Пример: Program.cs зависит от абстракций (ICommand), а не конкретных команд.

г) High Cohesion:

Классы сфокусированы на одной задаче:

    TimingCommandDecorator добавляет только логирование времени.

    OperationFactory создает операции с валидацией.
    
д) Protected Variations:

    Паттерны (декораторы, фабрики) защищают код от изменений.

    Пример: Добавление нового типа импорта не влияет на существующий код.

3. Паттерны GoF:

a) Фасад (Facade)

Цель: 
    Упростить взаимодействие с подсистемами, объединив связанные методы в единый интерфейс.

Реализация:

    BankAccountService – фасад для управления счетами (создание, обновление баланса, получение данных).

    CategoryService – фасад для работы с категориями (добавление, поиск, очистка).

    OperationService – фасад для операций (добавление, получение списка, расчет баланса).

    AnalyticsService – фасад для аналитики (расчет разницы доходов/расходов, группировка по категориям).

Важность:

    Сокрытие сложности: клиентский код (например, Program.cs) не зависит от внутренней логики хранения данных.

    Упрощение тестирования и модификации подсистем.

Классы:

    Services/BankAccountService.cs, Services/CategoryService.cs, Services/OperationService.cs, Services/AnalyticsService.cs.

б) Команда (Command) + Декоратор (Decorator)

Цель:

    Инкапсуляция действий в объекты (команды) для их выполнения, отмены или логирования.

    Расширение функционала команд без изменения их кода (например, замер времени выполнения).

Реализация:

Команда:

    Интерфейс ICommand и класс AddOperationCommand.

    Каждая операция (например, добавление, удаление) может быть представлена отдельной командой.

Декоратор:

    TimingCommandDecorator – добавляет замер времени выполнения команды.

Важность:

    Гибкость: команды можно комбинировать, откладывать выполнение, логировать.

    Соответствие принципу OCP (новый функционал добавляется через декораторы).

Классы:

    Commands/ICommand.cs, Commands/Commands/AddOperationCommand.cs, Commands/Decorators/TimingCommandDecorator.cs.

в) Шаблонный метод (Template Method)

Цель:
    Определение общего алгоритма для импорта данных, оставляя реализацию парсинга подклассам.

Реализация:

    Абстрактный класс DataImporter с методами:

        ImportData() – общий алгоритм (проверка файла → чтение → парсинг).

        ParseData() – абстрактный метод, реализуемый в наследниках.

    Конкретные классы: JsonImporter (JSON-парсинг), CsvImporter (CSV-парсинг).

Важность:

    Устранение дублирования кода: общая логика импорта (проверка файла, чтение) вынесена в базовый класс.

    Легкое добавление новых форматов (например, XML) через наследование.

Классы:

    Patterns/TemplateMethod/DataImporter.cs, Patterns/TemplateMethod/JsonImporter.cs, Patterns/TemplateMethod/CsvImporter.cs.

г) Посетитель (Visitor)

Цель: 
    Реализация экспорта данных в разные форматы (JSON, CSV) без изменения классов моделей.

Реализация:

    Интерфейс IExportVisitor с методами Visit() для каждого типа объекта.

    Конкретные посетители: JsonExportVisitor, CsvExportVisitor.

Важность:

    Отделение логики сериализации от бизнес-логики.

    Возможность добавления новых форматов (например, XML) без модификации моделей.

Классы:

    Visitors/IExportVisitor.cs, Visitors/JsonExportVisitor.cs, Visitors/CsvExportVisitor.cs.

д) Фабрика (Factory Method)

Цель: 
    Централизованное создание объектов с валидацией.

Реализация:

    Статический класс OperationFactory с методом Create(), который проверяет корректность суммы операции.

Важность:

    Гарантирует, что все операции создаются с валидными данными (например, amount > 0).

    Устраняет дублирование кода валидации.

Классы:

    Patterns/Factories/OperationFactory.cs.
